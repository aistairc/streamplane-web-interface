<!DOCTYPE html>
<html lang="en">
<head>
  <title>StreamPlane</title>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/gojs@3.0.18/release/go.js"></script>

<div id="allSampleContent" class="p-4 w-full">

  <script id="code">
    // These parameters need to be set before defining the templates.
    const MINLENGTH = 200; // this controls the minimum length of any swimlane
    const MINBREADTH = 20; // this controls the minimum breadth of any non-collapsed swimlane

    const ORIGIN_ID = "b14b2fc339142503bc15a3d8475cb7fc-task-Counter";
    const DEST_ID = "7c4a496ccc2c66bbbff8bdd6cdb3cc1a-task-Counter";
    const INPUT_ID = "5a73a19f-333a-4336-a2a7-4e4cbb132af9";
    const OUTPUT_ID = "26e2dd99-3b98-45d8-be47-d0fe2cd713cb";

    // some shared functions

    // this may be called to force the lanes to be laid out again
    function relayoutLanes() {
      myDiagram.nodes.each((lane) => {
        if (!(lane instanceof go.Group)) return;
        if (lane.category === 'Pool') return;
        lane.layout.isValidLayout = false; // force it to be invalid
      });
      myDiagram.layoutDiagram();
    }

    // this is called after nodes have been moved or lanes resized, to layout all of the Pool Groups again
    function relayoutDiagram(diagram) {
      diagram.layout.invalidateLayout();
      diagram.findTopLevelGroups().each((g) => {
        if (g.category === 'Pool') g.layout.invalidateLayout();
      });
      diagram.layoutDiagram();
    }

    // compute the minimum size of a Pool Group needed to hold all of the Lane Groups
    function computeMinPoolSize(pool) {
      // assert(pool instanceof go.Group && pool.category === "Pool");
      let len = MINLENGTH;
      pool.memberParts.each((lane) => {
        // pools ought to only contain lanes, not plain Nodes
        if (!(lane instanceof go.Group)) return;
        const holder = lane.placeholder;
        if (holder !== null) {
          len = Math.max(len, holder.actualBounds.width);
        }
      });
      return new go.Size(len, NaN);
    }

    // compute the minimum size for a particular Lane Group
    function computeLaneSize(lane) {
      // assert(lane instanceof go.Group && lane.category !== "Pool");
      const sz = computeMinLaneSize(lane);
      if (lane.isSubGraphExpanded) {
        const holder = lane.placeholder;
        if (holder !== null) {
          sz.height = Math.ceil(Math.max(sz.height, holder.actualBounds.height));
        }
      }
      // minimum breadth needs to be big enough to hold the header
      const hdr = lane.findObject('HEADER');
      if (hdr !== null) sz.height = Math.ceil(Math.max(sz.height, hdr.actualBounds.height));
      return sz;
    }

    // determine the minimum size of a Lane Group, even if collapsed
    function computeMinLaneSize(lane) {
      if (!lane.isSubGraphExpanded) return new go.Size(MINLENGTH, 1);
      return new go.Size(MINLENGTH, MINBREADTH);
    }

    // define a custom ResizingTool to limit how far one can shrink a lane Group
    class LaneResizingTool extends go.ResizingTool {
      constructor(init) {
        super();
        if (init) Object.assign(this, init);
      }

      isLengthening() {
        return this.handle.alignment === go.Spot.Right;
      }

      computeMinSize() {
        const lane = this.adornedObject.part;
        // assert(lane instanceof go.Group && lane.category !== "Pool");
        const msz = computeMinLaneSize(lane); // get the absolute minimum size
        if (this.isLengthening()) {
          // compute the minimum length of all lanes
          const sz = computeMinPoolSize(lane.containingGroup);
          msz.width = Math.max(msz.width, sz.width);
        } else {
          // find the minimum size of this single lane
          const sz = computeLaneSize(lane);
          msz.width = Math.max(msz.width, sz.width);
          msz.height = Math.max(msz.height, sz.height);
        }
        return msz;
      }

      resize(newr) {
        const lane = this.adornedObject.part;
        if (this.isLengthening()) {
          // changing the length of all of the lanes
          lane.containingGroup.memberParts.each((lane) => {
            if (!(lane instanceof go.Group)) return;
            const shape = lane.resizeObject;
            if (shape !== null) {
              // set its desiredSize length, but leave each breadth alone
              shape.width = newr.width;
            }
          });
        } else {
          // changing the breadth of a single lane
          super.resize(newr);
        }
        relayoutDiagram(this.diagram); // now that the lane has changed size, layout the pool again
      }
    }
    // end LaneResizingTool class

    class LaneLayout extends go.LayeredDigraphLayout {
      constructor(init) {
        super();
        // automatically lay out the lane's subgraph
        this.isInitial = false; // don't even do initial layout
        this.isOngoing = false; // don't invalidate layout when nodes or links are added or removed
        this.direction = 0;
        this.columnSpacing = 10;
        this.layeringOption = go.LayeredDigraphLayering.LongestPathSource;
      }

      doLayout(coll) {
        super.doLayout(coll);

        // coll.memberParts.each((node) => {
        //     if (!(node instanceof go.Node)) return;
        //     if(node.data.text.startsWith("Tokenizer (2")){
        //         node.moveTo(node.position.x + 200,node.position.y);
        //     }
        //     if(node.data.text.startsWith("Counter")){
        //         node.moveTo(400,node.position.y);
        //     }
        //     if(node.data.text.startsWith("Sink")){
        //         node.moveTo(600,node.position.y);
        //     }
        // });
      }
    }

    // define a custom grid layout that makes sure the length of each lane is the same
    // and that each lane is broad enough to hold its subgraph
    class PoolLayout extends go.GridLayout {
      constructor(init) {
        super();
        this.cellSize = new go.Size(1, 1);
        this.wrappingColumn = 1;
        this.wrappingWidth = Infinity;
        this.isRealtime = false; // don't continuously layout while dragging
        this.alignment = go.GridAlignment.Position;
        // This sorts based on the location of each Group.
        // This is useful when Groups can be moved up and down in order to change their order.
        this.comparer = (a, b) => {
          const ay = a.location.y;
          const by = b.location.y;
          if (isNaN(ay) || isNaN(by)) return 0;
          if (ay < by) return -1;
          if (ay > by) return 1;
          return 0;
        };
        this.boundsComputation = (part, layout, rect) => {
          part.getDocumentBounds(rect);
          rect.inflate(-1, -1); // negative strokeWidth of the border Shape
          return rect;
        };
        if (init) Object.assign(this, init);
      }

      doLayout(coll) {
        const diagram = this.diagram;
        if (diagram === null) return;
        diagram.startTransaction('PoolLayout');
        const pool = this.group;
        if (pool !== null && pool.category === 'Pool') {
          // make sure all of the Group Shapes are big enough
          const minsize = computeMinPoolSize(pool);
          pool.memberParts.each((lane) => {
            if (!(lane instanceof go.Group)) return;
            if (lane.category !== 'Pool') {
              const shape = lane.resizeObject;
              if (shape !== null) {
                // change the desiredSize to be big enough in both directions
                const sz = computeLaneSize(lane);
                shape.width = isNaN(shape.width)
                        ? minsize.width
                        : Math.max(shape.width, minsize.width);
                shape.height = !isNaN(shape.height) ? Math.max(shape.height, sz.height) : sz.height;
                const cell = lane.resizeCellSize;
                if (!isNaN(shape.width) && !isNaN(cell.width) && cell.width > 0)
                  shape.width = Math.ceil(shape.width / cell.width) * cell.width;
                if (!isNaN(shape.height) && !isNaN(cell.height) && cell.height > 0)
                  shape.height = Math.ceil(shape.height / cell.height) * cell.height;
              }
            }
          });
        }
        // now do all of the usual stuff, according to whatever properties have been set on this GridLayout
        super.doLayout(coll);
        diagram.commitTransaction('PoolLayout');
      }
    }
    // end PoolLayout class

    function init() {
      myDiagram = new go.Diagram('myDiagramDiv', {
        // use a custom ResizingTool (along with a custom ResizeAdornment on each Group)
        resizingTool: new LaneResizingTool(),
        // use a simple layout that ignores links to stack the top-level Pool Groups next to each other
        layout: new PoolLayout(),
        // don't allow dropping onto the diagram's background unless they are all Groups (lanes or pools)
        mouseDragOver: (e) => {
          if (!e.diagram.selection.all((n) => n instanceof go.Group)) {
            e.diagram.currentCursor = 'not-allowed';
          }
        },
        mouseDrop: (e) => {
          if (!e.diagram.selection.all((n) => n instanceof go.Group)) {
            e.diagram.currentTool.doCancel();
          }
        },
        // a clipboard copied node is pasted into the original node's group (i.e. lane).
        'commandHandler.copiesGroupKey': true,
        // automatically re-layout the swim lanes after dragging the selection
        SelectionMoved: (e) => relayoutDiagram(e.diagram),
        SelectionCopied: (e) => relayoutDiagram(e.diagram),
        'animationManager.isEnabled': false,
        // enable undo & redo
        'undoManager.isEnabled': true
      });

      // this is a Part.dragComputation function for limiting where a Node may be dragged
      // use GRIDPT instead of PT if DraggingTool.isGridSnapEnabled and movement should snap to grid
      function stayInGroup(part, pt, gridpt) {
        // don't constrain top-level nodes
        const grp = part.containingGroup;
        if (grp === null) return pt;
        // try to stay within the background Shape of the Group
        const back = grp.resizeObject;
        if (back === null) return pt;
        // allow dragging a Node out of a Group if the Shift key is down
        if (part.diagram.lastInput.shift) return pt;
        const r = back.getDocumentBounds();
        const b = part.actualBounds;
        const loc = part.location;
        // find the padding inside the group's placeholder that is around the member parts
        const m = grp.placeholder.padding;
        // now limit the location appropriately
        const x =
                Math.max(r.x + m.left, Math.min(pt.x, r.right - m.right - b.width - 1)) + (loc.x - b.x);
        const y =
                Math.max(r.y + m.top, Math.min(pt.y, r.bottom - m.bottom - b.height - 1)) + (loc.y - b.y);
        return new go.Point(x, y);
      }


      const portSize = new go.Size(8, 8);
      const portColors = ['red', 'green', 'white'];

      // To simplify this code we define a function for creating a context menu button:
      function makeButton(text, action, visiblePredicate) {
        const obj = go.GraphObject.build('ContextMenuButton', {
          click: action
        }).add(new go.TextBlock(text));

        if (visiblePredicate)
          obj.bindObject('visible', '', (o, e) => (o.diagram ? visiblePredicate(o, e) : false));
        return obj;
      }

      const nodeMenu = // context menu for each Node
              go.GraphObject.build('ContextMenu')
                      .add(
                              makeButton('Activate', (e, obj) => {
                                var url ='http://localhost:8080/setInstanceStatus?operatorCacheKey=';
                                url += obj.part.data.cacheId;
                                url += '&subtaskIndex=';
                                url += obj.part.data.subtaskIndex;
                                url += '&status=Running';
                                fetch(url);
                                e.diagram.commit(d => {
                                  d.model.set(obj.part.data, "active", true);
                                }, "activate");
                              }),
                              makeButton('Deactivate', (e, obj) => {
                                var url ='http://localhost:8080/setInstanceStatus?operatorCacheKey=';
                                url += obj.part.data.cacheId;
                                url += '&subtaskIndex=';
                                url += obj.part.data.subtaskIndex;
                                url += '&status=Paused';
                                fetch(url);
                                e.diagram.commit(d => {
                                  d.model.set(obj.part.data, "active", false);
                                }, "deactivate");
                              })
                      );

      const edgeMenu = // context menu for each Node
              go.GraphObject.build('ContextMenu')
                      .add(
                              makeButton('Switch to In-memory', (e, obj) => {
                                var url ='http://localhost:8080/convertChannel?outputStreamId=';
                                url += obj.part.data.streamId;
                                url += '&channelIndex=';
                                url += obj.part.data.channelIndex;
                                url += '&mode=in-memory';
                                fetch(url);
                                e.diagram.commit(d => {
                                  d.model.set(obj.part.data, "imdg", true);
                                }, "activate");
                              }),
                              makeButton('Switch to Built-in', (e, obj) => {
                                var url ='http://localhost:8080/convertChannel?outputStreamId=';
                                url += obj.part.data.streamId;
                                url += '&channelIndex=';
                                url += obj.part.data.channelIndex;
                                url += '&mode=built-in';
                                fetch(url);
                                e.diagram.commit(d => {
                                  d.model.set(obj.part.data, "imdg", false);
                                }, "deactivate");
                              })
                      );

      myDiagram.themeManager.set('', {
        colors: { ports: portColors }
      });

      myDiagram.nodeTemplate = new go.Node('Table', {
        // limit dragging of Nodes to stay within the containing Group, defined above
        dragComputation: stayInGroup,
        locationObjectName: 'BODY',
        locationSpot: go.Spot.Center,
        selectionObjectName: 'BODY',
        contextMenu: nodeMenu,
        linkConnected: (n, l, p) => {
          var data = l.part.data;
          if(data.imdg){
            const toPort = l.toPort;

            if(toPort instanceof go.Node){ //Input
              var url ='http://localhost:8080/setInputStream?operatorCacheKey=';
              url += n.part.data.cacheId;
              url += '&subtaskIndex=';
              url += n.part.data.subtaskIndex;
              url += '&inputStreamId=';
              url += data.streamId;
              fetch(url);
            } else { //output
              var url ='http://localhost:8080/setOutputStream?operatorCacheKey=';
              url += n.part.data.cacheId;
              url += '&subtaskIndex=';
              url += n.part.data.subtaskIndex;
              url += '&outputStreamId=';
              url += data.streamId;
              fetch(url);
            }
          }

        },
        linkDisconnected: (n, l, p) => {

        }
      })
              .bindTwoWay('location', 'loc', go.Point.parse, go.Point.stringify)
              .add(
                      // the body
                      new go.Panel('Auto', {
                        row: 1,
                        column: 1,
                        name: 'BODY',
                        stretch: go.Stretch.Fill
                      })
                              .add(
                                      new go.Shape('Rectangle', {
                                        fill: 'lightgray',
                                        stroke: 'gray',
                                        cursor: 'grab',
                                        strokeWidth: 0.5,
                                        minSize: new go.Size(20, 40)
                                      })
                                              .bind('fill', 'active', (active) => (active ? 'lightgreen':'lightgray'))
                                              .bind('visible', 'hidden', (hidden) => (!hidden)),
                                      new go.TextBlock({
                                        margin: 10,
                                        cursor: 'grab',
                                        textAlign: 'center',
                                        font: 'bold 14px Segoe UI,sans-serif',
                                        stroke: '#484848'
                                      })
                                              .bind('text', 'text')
                                              .bind('stroke', 'hidden', (hidden) => (hidden? "white":'#484848'))
                              ),
                      // the Panel holding the left port elements, which are themselves Panels,
                      // created for each item in the itemArray, bound to data.topArray
                      new go.Panel('Vertical', {
                        row: 1,
                        column: 0,
                        itemTemplate: new go.Panel({
                          fromSpot: go.Spot.Left,
                          toSpot: go.Spot.Left,
                          fromMaxLinks: 2,
                          toMaxLinks: 2,
                          cursor: 'pointer',
                          fromLinkable: false,
                          toLinkable: true
                        })
                                .bind('portId', 'channelId')
                                .add(
                                        new go.Shape('Rectangle', {
                                          stroke: null,
                                          strokeWidth: 0,
                                          desiredSize: portSize,
                                          margin: new go.Margin(0, 1)
                                        }).themeData('fill', 'portColor', 'ports')
                                )
                      }).bind('itemArray', 'inputs'),
                      // the Panel holding the left port elements, which are themselves Panels,
                      // created for each item in the itemArray, bound to data.topArray
                      new go.Panel('Vertical', {
                        row: 1,
                        column: 2,
                        itemTemplate: new go.Panel({
                          fromSpot: go.Spot.Right,
                          toSpot: go.Spot.Right,
                          fromMaxLinks: 2,
                          toMaxLinks: 2,
                          cursor: 'pointer',
                          fromLinkable: true,
                          toLinkable: false
                        })
                                .bind('portId', 'channelId')
                                .add(
                                        new go.Shape('Rectangle', {
                                          stroke: null,
                                          strokeWidth: 0,
                                          desiredSize: portSize,
                                          margin: new go.Margin(0, 1)
                                        }).themeData('fill', 'portColor', 'ports')
                                )
                      }).bind('itemArray', 'outputs')
              );

      function groupStyle(obj) {
        // common settings for both Lane and Pool Groups
        let obj2 = {
          layerName: 'Background', // all pools and lanes are always behind all nodes and links
          background: 'transparent', // can grab anywhere in bounds
          movable: true, // allows users to re-order by dragging
          copyable: false, // can't copy lanes or pools
          avoidable: false, // don't impede AvoidsNodes routed Links
          minLocation: new go.Point(NaN, -Infinity), // only allow vertical movement
          maxLocation: new go.Point(NaN, Infinity)
        };

        // apply settings to given obj
        if (!obj) return obj2;
        Object.keys(obj2).forEach((p) => {
          if (obj[p]) return; // dont change things already defined
          obj[p] = obj2[p];
        });
        return obj;
      }

      // hide links between lanes when either lane is collapsed
      function updateCrossLaneLinks(group) {
        group.findExternalLinksConnected().each((l) => {
          l.visible = l.fromNode.isVisible() && l.toNode.isVisible();
        });
      }

      // each Group is a "swimlane" with a header on the left and a resizable lane on the right
      myDiagram.groupTemplateMap.add(
              'Lane',
              new go.Group('Horizontal',
                      groupStyle({
                        selectionObjectName: 'SHAPE', // selecting a lane causes the body of the lane to be highlit, not the label
                        resizable: true,
                        resizeObjectName: 'SHAPE', // the custom resizeAdornmentTemplate only permits two kinds of resizing
                        layout: new LaneLayout(),
                        computesBoundsAfterDrag: true, // needed to prevent recomputing Group.placeholder bounds too soon
                        computesBoundsIncludingLinks: false, // to reduce occurrences of links going briefly outside the lane
                        computesBoundsIncludingLocation: true, // to support empty space at top-left corner of lane
                        handlesDragDropForMembers: true, // don't need to define handlers on member Nodes and Links
                        mouseDrop: (e, grp) => {
                          // dropping a copy of some Nodes and Links onto this Group adds them to this Group
                          if (!e.shift) return; // cannot change groups with an unmodified drag-and-drop
                          // don't allow drag-and-dropping a mix of regular Nodes and Groups
                          if (!e.diagram.selection.any((n) => n instanceof go.Group)) {
                            const ok = grp.addMembers(grp.diagram.selection, true);
                            if (ok) {
                              updateCrossLaneLinks(grp);
                            } else {
                              grp.diagram.currentTool.doCancel();
                            }
                          } else {
                            e.diagram.currentTool.doCancel();
                          }
                        },
                        subGraphExpandedChanged: (grp) => {
                          const shp = grp.resizeObject;
                          if (grp.diagram.undoManager.isUndoingRedoing) return;
                          if (grp.isSubGraphExpanded) {
                            shp.height = grp.data.savedBreadth;
                          } else {
                            if (!isNaN(shp.height)) grp.diagram.model.set(grp.data, 'savedBreadth', shp.height);
                            shp.height = NaN;
                          }
                          updateCrossLaneLinks(grp);
                        }
                      })
              )
                      .bindTwoWay('location', 'loc', go.Point.parse, go.Point.stringify)
                      .bindTwoWay('isSubGraphExpanded', 'expanded')
                      .add(
                              // the lane header consisting of a Shape and a TextBlock
                              new go.Panel('Horizontal', {
                                name: 'HEADER',
                                angle: 270, // maybe rotate the header to read sideways going up
                                alignment: go.Spot.Center
                              })
                                      .add(
                                              new go.Panel('Horizontal') // this is hidden when the swimlane is collapsed
                                                      .bindObject('visible', 'isSubGraphExpanded')
                                                      .add(
                                                              new go.TextBlock({
                                                                font: 'bold 13pt sans-serif',
                                                                editable: true,
                                                                margin: new go.Margin(2, 0, 0, 0)
                                                              }).bindTwoWay('text')
                                                      ),
                                              go.GraphObject.build('SubGraphExpanderButton', { margin: 5 }) // but this remains always visible!
                                      ), // end Horizontal Panel
                              new go.Panel('Auto') // the lane consisting of a background Shape and a Placeholder representing the subgraph
                                      .add(
                                              new go.Shape('Rectangle', { // this is the resized object
                                                name: 'SHAPE',
                                                fill: 'white'
                                              })
                                                      .bind('fill', 'color')
                                                      .bindTwoWay('desiredSize', 'size', go.Size.parse, go.Size.stringify),
                                              new go.Placeholder({ padding: 12, alignment: go.Spot.TopLeft }),
                                              new go.TextBlock({
                                                // this TextBlock is only seen when the swimlane is collapsed
                                                name: 'LABEL',
                                                font: 'bold 13pt sans-serif',
                                                editable: true,
                                                angle: 0,
                                                alignment: go.Spot.TopLeft,
                                                margin: new go.Margin(2, 0, 0, 4)
                                              })
                                                      .bindObject('visible', 'isSubGraphExpanded', (e) => !e)
                                                      .bindTwoWay('text')
                                      ) // end Auto Panel
                      )
      ); // end Group

      // define a custom resize adornment that has two resize handles if the group is expanded
      myDiagram.groupTemplateMap.get('Lane').resizeAdornmentTemplate = new go.Adornment('Spot')
              .add(
                      new go.Placeholder(),
                      new go.Shape({
                        // for changing the length of a lane
                        alignment: go.Spot.Right,
                        desiredSize: new go.Size(7, 50),
                        fill: 'lightblue',
                        stroke: 'dodgerblue',
                        cursor: 'col-resize'
                      }).bindObject('visible', '', (ad) => {
                        if (ad.adornedPart === null) return false;
                        return ad.adornedPart.isSubGraphExpanded;
                      }),
                      new go.Shape({
                        // for changing the breadth of a lane
                        alignment: go.Spot.Bottom,
                        desiredSize: new go.Size(50, 7),
                        fill: 'lightblue',
                        stroke: 'dodgerblue',
                        cursor: 'row-resize'
                      }).bindObject('visible', '', (ad) => {
                        if (ad.adornedPart === null) return false;
                        return ad.adornedPart.isSubGraphExpanded;
                      })
              );

      myDiagram.groupTemplateMap.add(
              'Pool',
              new go.Group('Auto',
                      groupStyle({
                        // use a simple layout that ignores links to stack the "lane" Groups on top of each other
                        layout: new PoolLayout({ spacing: new go.Size(5, 5) }) // no space between lanes
                      })
              )
                      .bindTwoWay('location', 'loc', go.Point.parse, go.Point.stringify)
                      .add(
                              new go.Shape({ fill: 'white' }).bind('fill', 'color'),
                              new go.Panel('Table', { defaultColumnSeparatorStroke: 'black' })
                                      .add(
                                              new go.Panel('Horizontal', { column: 0, angle: 270 })
                                                      .add(
                                                              new go.TextBlock({
                                                                font: 'bold 16pt sans-serif',
                                                                editable: true,
                                                                margin: new go.Margin(2, 0, 0, 0)
                                                              }).bindTwoWay('text')
                                                      ),
                                              new go.Placeholder({ column: 1 })
                                      )
                      )
      );

      myDiagram.linkTemplate = new go.Link({
        routing: go.Routing.AvoidsNodes,
        corner: 5,
        curve: go.Curve.JumpGap,
        relinkableFrom: true,
        relinkableTo: true
      })
              .add(
                      new go.Shape({
                        strokeWidth: 2,
                        contextMenu: edgeMenu,
                      })
                              .bind('stroke', 'imdg', (imdg) => (imdg ? 'blue' : 'black'))
                              .bind('visible', 'hidden', (hidden) => (!hidden)),
                      new go.Shape({ toArrow: 'standard', stroke: null, scale: 1.5, fill: 'black' })
                              .bind('fill', 'imdg', (imdg) => (imdg ? 'blue' : 'black'))
                              .bind('visible', 'hidden', (hidden) => (!hidden)),
              );

      // define some sample graphs in some of the lanes
      myDiagram.model.linkFromPortIdProperty = "fromPort";
      myDiagram.model.linkToPortIdProperty = "toPort";
      myDiagram.model = new go.GraphLinksModel({
        linkFromPortIdProperty: "fromPort",
        linkToPortIdProperty: "toPort",
        nodeDataArray: [
          // node data
          { key: 'flink1', text: 'Flink 1', isGroup: true, category: 'Pool' },
          { key: 'flink2', text: 'Flink 2', isGroup: true, category: 'Pool' },
          {
            key: 'tm1-1',
            text: 'TM 1-1',
            isGroup: true,
            category: 'Lane',
            group: 'flink1'
          },
          {
            key: 'tm1-2',
            text: 'TM 1-2',
            isGroup: true,
            category: 'Lane',
            group: 'flink1'
          },
          {
            key: 'tm2-1',
            text: 'TM 2-1',
            isGroup: true,
            category: 'Lane',
            group: 'flink2'
          },
          {
            key: 'tm2-2',
            text: 'TM 2-2',
            isGroup: true,
            category: 'Lane',
            group: 'flink2'
          },
          { key: "j1o1", text: 'Source (1/1)', group: 'tm1-1', active: true,
            outputs:[{"channelId":"j1o1o1", portColor: 0}, {"channelId":"j1o1o2", portColor: 1}] },
          { key: "j1o2", text: 'Source    (2/1)', group: 'tm1-2', active: false, hidden: true},
          { key: "j1o3", text: 'Tokenizer (1/2)', group: 'tm1-1', active: true,
            inputs:[{"channelId":"j1o3i1", portColor: 0}],
            outputs:[{"channelId":"j1o3o1", portColor: 0}, {"channelId":"j1o3o2", portColor: 1}]},
          { key: "j1o4", text: 'Tokenizer (2/2)', group: 'tm1-2', active: true,
            inputs:[{"channelId":"j1o4i1", portColor: 1}],
            outputs:[{"channelId":"j1o4o1", portColor: 0}, {"channelId":"j1o4o2", portColor: 1}]},
          { key: "j1o5", text: 'Counter (1/2)', group: 'tm1-1', active: true,
            inputs:[{"channelId":"j1o5i1", portColor: 0}, {"channelId":"j1o5i2", portColor: 0}],
            outputs:[{"channelId":"j1o5o1", portColor: 0}]},
          { key: "j1o6", text: 'Counter (2/2)', group: 'tm1-2', active: true, cacheId: ORIGIN_ID, subtaskIndex: 1,
            inputs:[{"channelId":"j1o6i1", portColor: 1}, {"channelId":"j1o6i2", portColor: 1}],
            outputs:[{"channelId":"j1o6o1", portColor: 1}]},
          { key: "j1o7", text: 'Sink (1/2)', group: 'tm1-1', active: true,
            inputs:[{"channelId":"j1o7i1", portColor: 0}]},
          { key: "j1o8", text: 'Sink (2/2)', group: 'tm1-2', active: true,
            inputs:[{"channelId":"j1o8i1", portColor: 1}]},

          { key: "j2o1", text: 'Source (1/1)', group: 'tm2-1', active: false,
            outputs:[{"channelId":"j2o1o1", portColor: 0}] },
          { key: "j2o2", text: 'Source    (2/1)', group: 'tm2-2', active: false, hidden: true},
          { key: "j2o3", text: 'Tokenizer (1/2)', group: 'tm2-1', active: false,
            inputs:[{"channelId":"j2o3i1", portColor: 0}],
            outputs:[{"channelId":"j2o3o1", portColor: 0}, {"channelId":"j2o3o2", portColor: 1}]},
          { key: "j2o4", text: 'Tokenizer (2/2)', group: 'tm2-2', active: false,
            inputs:[{"channelId":"j2o4i1", portColor: 1}],
            outputs:[{"channelId":"j2o4o1", portColor: 0}, {"channelId":"j2o4o2", portColor: 1}]},
          { key: "j2o5", text: 'Counter (1/2)', group: 'tm2-1', active: false,
            inputs:[{"channelId":"j2o5i1", portColor: 0}, {"channelId":"j2o5i2", portColor: 0}],
            outputs:[{"channelId":"j2o5o1", portColor: 0}]},
          { key: "j2o6", text: 'Counter (2/2)', group: 'tm2-2', active: false, cacheId: DEST_ID, subtaskIndex: 1,
            inputs:[{"channelId":"j2o6i1", portColor: 1}, {"channelId":"j2o6i2", portColor: 1}],
            outputs:[{"channelId":"j2o6o1", portColor: 1}]},
          { key: "j2o7", text: 'Sink (1/2)', group: 'tm2-1', active: false,
            inputs:[{"channelId":"j2o7i1", portColor: 0}]},
          { key: "j2o8", text: 'Sink (2/2)', group: 'tm2-2', active: false,
            inputs:[{"channelId":"j2o8i1", portColor: 1}]}

        ],
        linkDataArray: [
          // link data
          { from: 'j1o1', to: 'j1o3', fromPort: 'j1o1o1', toPort: 'j1o3i1', imdg: false},
          { from: 'j1o1', to: 'j1o4', fromPort: 'j1o1o2', toPort: 'j1o4i1', imdg: false},
          { from: 'j1o2', to: 'j1o4', fromPort: 'j1o2o1', toPort: 'j1o4i1', imdg: false, hidden: true},
          { from: 'j1o3', to: 'j1o5', fromPort: 'j1o3o1', toPort: 'j1o5i1', imdg: false},
          { from: 'j1o3', to: 'j1o6', fromPort: 'j1o3o2', toPort: 'j1o6i1', imdg: false, streamId: INPUT_ID, channelIndex: 1},
          { from: 'j1o4', to: 'j1o5', fromPort: 'j1o4o1', toPort: 'j1o5i2', imdg: false},
          { from: 'j1o4', to: 'j1o6', fromPort: 'j1o4o2', toPort: 'j1o6i2', imdg: false, streamId: INPUT_ID, channelIndex: 1},
          { from: 'j1o5', to: 'j1o7', fromPort: 'j1o5o1', toPort: 'j1o7i1', imdg: false},
          { from: 'j1o6', to: 'j1o8', fromPort: 'j1o6o1', toPort: 'j1o8i1', imdg: false, streamId: OUTPUT_ID, channelIndex: 1},


          { from: 'j2o1', to: 'j2o3', fromPort: 'j2o1o1', toPort: 'j2o3i1', imdg: false, hidden: true},
          { from: 'j2o2', to: 'j2o4', fromPort: 'j2o2o1', toPort: 'j2o4i1', imdg: false, hidden: true},
          { from: 'j2o3', to: 'j2o5', fromPort: 'j2o3o1', toPort: 'j2o5i1', imdg: false, hidden: true},
          { from: 'j2o3', to: 'j2o6', fromPort: 'j2o3o2', toPort: 'j2o6i1', imdg: false, hidden: true},
          { from: 'j2o4', to: 'j2o5', fromPort: 'j2o4o1', toPort: 'j2o5i2', imdg: false, hidden: true},
          { from: 'j2o4', to: 'j2o6', fromPort: 'j2o4o2', toPort: 'j2o6i2', imdg: false, hidden: true},
          { from: 'j2o5', to: 'j2o7', fromPort: 'j2o5o1', toPort: 'j2o7i1', imdg: false, hidden: true},
          { from: 'j2o6', to: 'j2o8', fromPort: 'j2o8o1', toPort: 'j2o8i1', imdg: false, hidden: true}
        ]
      });

      // myDiagram.addModelChangedListener(evt => {
      //   // ignore unimportant Transaction events
      //   if (!evt.isTransactionFinished) return;
      //   const txn = evt.object;  // a Transaction
      //   if (txn === null) return;
      //   // iterate over all of the actual ChangedEvents of the Transaction
      //   txn.changes.each(e => {
      //     // record node insertions and removals

      //     if (e.change === go.ChangeType.Property) {
      //       if (e.modelChange === "linkFromKey") {
      //         console.dir(evt.propertyName + " changed From key of link: " +
      //                     e.object + " from: " + e.oldValue + " to: " + e.newValue);
      //       } else if (e.modelChange === "linkToKey") {
      //         console.log(evt.propertyName + " changed To key of link: " +
      //                     e.object + " from: " + e.oldValue + " to: " + e.newValue);
      //       }
      //     } else if (e.change === go.ChangeType.Insert && e.modelChange === "linkDataArray") {
      //       console.dir(e);
      //       // console.dir(e.oldValue);
      //       // console.dir(e.newValue);
      //     } else if (e.change === go.ChangeType.Remove && e.modelChange === "linkDataArray") {
      //       console.dir(e.oldValue);
      //     }
      //   });
      // });

      // force all lanes' layouts to be performed
      relayoutLanes();
      // save();
    } // end init

    // function save() {
    //   document.getElementById('mySavedModel').value = myDiagram.model.toJson();
    //   myDiagram.isModified = false;
    // }
    // function load() {
    //   myDiagram.model = go.Model.fromJson(document.getElementById('mySavedModel').value);
    //   myDiagram.delayInitialization(relayoutDiagram);
    // }


    window.addEventListener('DOMContentLoaded', init);
  </script>
  <div id="sample">
    <div id="myDiagramDiv" style="width: 100%; height: 700px; top: -100px"></div>
    <!-- <button onclick="relayoutLanes()">Diagram Layout</button> -->
    <!-- <button id="SaveButton" onclick="save()">Save</button>
    <button onclick="load()">Load</button>
    <textarea id="mySavedModel" style="width: 100%; height: 300px"></textarea> -->
  </div>
  <h2 style="position: absolute; color:blue; top: 0px; left: 300px;">StreamPlane Demo: WordCount</h2>
</body>
</html>